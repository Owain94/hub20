import logging
from typing import Dict

import celery_pubsub
from celery import shared_task
from django.db.models import Q
from web3.datastructures import AttributeDict
from web3.exceptions import TransactionNotFound

from hub20.apps.core.models.tokens import BaseToken
from hub20.apps.core.tasks import broadcast_event

from . import signals
from .abi.tokens import EIP20_ABI
from .constants import Events
from .models import (
    BaseWallet,
    Block,
    Chain,
    TransactionDataRecord,
    WalletBalanceRecord,
    Web3Provider,
)

logger = logging.getLogger(__name__)


@shared_task
def notify_block_created(chain_id, block_data):
    logger.debug(f"Sending notification of of block created on #{chain_id}")
    block_data = AttributeDict(block_data)
    broadcast_event(
        event=Events.BLOCK_CREATED.value,
        chain_id=chain_id,
        hash=block_data.hash,
        number=block_data.number,
        timestamp=block_data.timestamp,
    )


# Tasks that are setup to subscribe and handle events generated by the event streams
@shared_task
def notify_new_block(chain_id, block_data: Dict, provider_url):
    block_data = AttributeDict(block_data)
    logger.debug(f"Sending notification of new block on chain #{chain_id}")
    signals.block_sealed.send(sender=Block, chain_id=chain_id, block_data=block_data)


@shared_task
def check_pending_transaction_for_eth_transfer(chain_id, transaction_data):
    chain = Chain.actve.get(id=chain_id)

    sender = transaction_data["from"]
    recipient = transaction_data["to"]

    is_native_token_transfer = transaction_data.value != 0

    if not is_native_token_transfer:
        return

    native_token = BaseToken.make_native(chain=chain)
    amount = native_token.from_wei(transaction_data.value)

    for account in BaseWallet.objects.filter(address=sender):
        tx_data = TransactionDataRecord.make(tx_data=transaction_data, chain_id=chain_id)

        signals.outgoing_transfer_broadcast.send(
            sender=TransactionDataRecord,
            account=account,
            amount=amount,
            transaction_data=tx_data,
        )

    for account in BaseWallet.objects.filter(address=recipient):
        tx_data = TransactionDataRecord.make(tx_data=transaction_data, chain_id=chain_id)

        signals.incoming_transfer_broadcast.send(
            sender=BaseToken,
            account=account,
            amount=amount,
            transaction_data=tx_data,
        )


@shared_task
def check_pending_erc20_transfer_event(chain_id, event_data, provider_url):
    try:
        token = BaseToken.objects.get(chain_id=chain_id, address=event_data.address)
    except BaseToken.DoesNotExist:
        return

    sender = event_data.args._from
    recipient = event_data.args._to

    if not BaseWallet.objects.filter(Q(address=sender) | Q(address=recipient)).exists():
        return

    amount = token.from_wei(event_data.args._value)

    try:
        provider = Web3Provider.objects.get(url=provider_url)
        w3 = provider.w3
        transaction_data = w3.eth.get_transaction(event_data.transactionHash)
    except TransactionNotFound:
        logger.warning(f"Failed to get transaction data {event_data.transactionHash.hex()}")
        return

    for account in BaseWallet.objects.filter(address=sender):
        tx_data = TransactionDataRecord.make(tx_data=transaction_data, chain_id=chain_id)
        signals.outgoing_transfer_broadcast.send(
            sender=TransactionDataRecord,
            account=account,
            amount=amount,
            transaction_data=tx_data,
        )

    for account in BaseWallet.objects.filter(address=recipient):
        tx_data = TransactionDataRecord.make(tx_data=transaction_data, chain_id=chain_id)
        signals.incoming_transfer_broadcast.send(
            sender=TransactionDataRecord,
            account=account,
            amount=amount,
            transaction_data=tx_data,
        )


@shared_task
def update_wallet_erc20_token_balances():
    for provider in Web3Provider.available.all():
        try:
            current_block = provider.w3.eth.block_number
        except Exception:
            logger.exception(f"Failed to get block info on {provider}")
            continue

        for wallet in BaseWallet.objects.all():
            for token in provider.chain.tokens.all():
                last_recorded_balance = wallet.current_balance(token)
                last_recorded_block = last_recorded_balance and last_recorded_balance.block

                if last_recorded_block is None or last_recorded_block.number < current_block:
                    try:
                        contract = provider.w3.eth.contract(abi=EIP20_ABI, address=token.address)
                        current_balance = contract.functions.balanceOf(wallet.address).call()
                        balance_amount = token.from_wei(current_balance)
                        block_data = provider.w3.eth.get_block(current_block)
                        block = Block.make(block_data=block_data, chain_id=token.chain_id)

                        WalletBalanceRecord.objects.create(
                            wallet=wallet,
                            currency=balance_amount.currency,
                            amount=balance_amount.amount,
                            block=block,
                        )
                    except Exception:
                        logger.exception(f"Failed to get {token} balance for {wallet.address}")


@shared_task
def update_wallet_native_token_balances():
    for provider in Web3Provider.available.all():
        try:
            current_block = provider.w3.eth.block_number
        except Exception:
            logger.exception(f"Failed to get block info on {provider}")
            continue

        for wallet in BaseWallet.objects.all():
            token = provider.chain.native_token
            last_recorded_balance = wallet.current_balance(token)
            last_recorded_block = last_recorded_balance and last_recorded_balance.block

            if last_recorded_block is None or last_recorded_block.number < current_block:
                try:
                    block_data = provider.w3.eth.get_block(current_block)
                    balance = token.from_wei(
                        provider.w3.eth.get_balance(
                            wallet.address, block_identifier=block_data.hash.hex()
                        )
                    )

                    block = Block.make(block_data=block_data, chain_id=token.chain_id)

                    WalletBalanceRecord.objects.create(
                        wallet=wallet,
                        currency=balance.currency,
                        amount=balance.amount,
                        block=block,
                    )

                except Exception:
                    logger.exception(f"Failed to get {token} balance for {wallet.address}")


celery_pubsub.subscribe("blockchain.mined.block", notify_new_block)
celery_pubsub.subscribe(
    "blockchain.event.token_transfer.broadcast", check_pending_erc20_transfer_event
)
celery_pubsub.subscribe(
    "blockchain.broadcast.transaction", check_pending_transaction_for_eth_transfer
)
